// Code generated by protoc-gen-go. DO NOT EDIT.
// source: components/automate-gateway/api/iam/v2/rules.proto

package v2

import (
	context "context"
	fmt "fmt"
	request "github.com/chef/automate/components/automate-gateway/api/iam/v2/request"
	response "github.com/chef/automate/components/automate-gateway/api/iam/v2/response"
	_ "github.com/chef/automate/components/automate-grpc/protoc-gen-policy/api"
	_ "github.com/chef/automate/components/automate-grpc/protoc-gen-policy/iam"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("components/automate-gateway/api/iam/v2/rules.proto", fileDescriptor_28c6f49a8332221c)
}

var fileDescriptor_28c6f49a8332221c = []byte{
	// 907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x8b, 0x1c, 0x45,
	0x1c, 0xa5, 0xf6, 0x2b, 0x5a, 0x4a, 0x92, 0xad, 0x89, 0x30, 0xb6, 0x39, 0x0c, 0x85, 0x62, 0x18,
	0xb6, 0xbb, 0x75, 0xbc, 0x8d, 0x07, 0x9d, 0x6c, 0x7a, 0x15, 0x49, 0xb2, 0x3a, 0x43, 0x3c, 0x28,
	0x61, 0xa9, 0xed, 0x29, 0x7b, 0x3b, 0x74, 0x77, 0x55, 0xba, 0xaa, 0x77, 0x33, 0x2c, 0x0b, 0x12,
	0x10, 0x71, 0x0f, 0x1e, 0x56, 0x04, 0x2f, 0x9e, 0x3c, 0xf8, 0x07, 0xc8, 0xdc, 0x05, 0xef, 0x82,
	0xe8, 0x5d, 0x84, 0x88, 0x90, 0x83, 0x07, 0x41, 0x11, 0x24, 0x20, 0x55, 0xdd, 0xf3, 0xd1, 0x3b,
	0xd3, 0x99, 0x6e, 0x58, 0x72, 0xda, 0xad, 0xfe, 0xbd, 0xf7, 0xe3, 0xbd, 0xd7, 0x6f, 0x9a, 0x82,
	0x2d, 0x97, 0x85, 0x9c, 0x45, 0x34, 0x92, 0xc2, 0x26, 0x89, 0x64, 0x21, 0x91, 0xd4, 0xf4, 0x88,
	0xa4, 0x07, 0x64, 0x60, 0x13, 0xee, 0xdb, 0x3e, 0x09, 0xed, 0xfd, 0x96, 0x1d, 0x27, 0x01, 0x15,
	0x16, 0x8f, 0x99, 0x64, 0xa8, 0xee, 0xee, 0xd1, 0x8f, 0xac, 0x11, 0xda, 0x22, 0xdc, 0xb7, 0x7c,
	0x12, 0x5a, 0xfb, 0x2d, 0xe3, 0xb2, 0xc7, 0x98, 0x17, 0x50, 0x4d, 0x24, 0x51, 0xc4, 0x24, 0x91,
	0x3e, 0x8b, 0x32, 0x9e, 0xb1, 0xa1, 0xff, 0xb8, 0xa6, 0x47, 0x23, 0x53, 0x1c, 0x10, 0xcf, 0xa3,
	0xb1, 0xcd, 0xb8, 0x46, 0xcc, 0x41, 0xb7, 0xcb, 0x2a, 0xa3, 0x77, 0x13, 0x2a, 0xe4, 0xb4, 0x42,
	0xe3, 0xf5, 0xd2, 0x5c, 0xc1, 0x59, 0x24, 0x68, 0x8e, 0xfc, 0xe6, 0x5c, 0x72, 0xcc, 0x5d, 0x7b,
	0x4a, 0x3f, 0x67, 0x81, 0xef, 0x0e, 0x0a, 0x8c, 0x56, 0xd9, 0xa0, 0x94, 0xcc, 0x6c, 0x68, 0xfd,
	0x59, 0x83, 0xab, 0x5d, 0xa5, 0x09, 0x7d, 0xb9, 0x02, 0xe1, 0x66, 0x4c, 0x89, 0xa4, 0xea, 0x8c,
	0x5e, 0xb6, 0x8a, 0xc2, 0xb7, 0x26, 0xa8, 0x2e, 0xbd, 0x6b, 0x5c, 0x29, 0x07, 0x14, 0x1c, 0x7f,
	0xb7, 0x7c, 0xd2, 0xf9, 0x6a, 0x09, 0xae, 0xea, 0x0c, 0xee, 0x7c, 0xbe, 0x04, 0xcf, 0xdf, 0x33,
	0x5d, 0xd6, 0xa7, 0xa6, 0x20, 0x21, 0x57, 0x12, 0xfe, 0x03, 0xad, 0x7f, 0x01, 0xfc, 0x1b, 0x34,
	0xff, 0x02, 0xf0, 0x3c, 0x5c, 0x09, 0x48, 0xe4, 0xa1, 0x35, 0x63, 0xe5, 0x9d, 0xde, 0xf6, 0x4d,
	0xf8, 0x2b, 0x80, 0x6b, 0x82, 0x25, 0xb1, 0x4b, 0xd1, 0x2f, 0xc0, 0xf8, 0x09, 0x1c, 0x62, 0xbf,
	0x8f, 0xdb, 0x0d, 0x4c, 0xef, 0x69, 0xb2, 0xa9, 0x96, 0xe2, 0x8d, 0x06, 0xe6, 0x31, 0xbb, 0x43,
	0x5d, 0x69, 0xe6, 0xa7, 0xd9, 0x53, 0x05, 0x88, 0x48, 0x48, 0xd5, 0xe8, 0xc6, 0xa0, 0xe1, 0xa4,
	0xd3, 0x46, 0x37, 0xe3, 0xca, 0x01, 0xd7, 0xa3, 0x9b, 0xdb, 0xd7, 0x1c, 0x75, 0x76, 0x59, 0xd4,
	0xf7, 0x75, 0x5a, 0xb8, 0xdd, 0xf8, 0xf0, 0x10, 0x13, 0x29, 0x63, 0x7f, 0x37, 0x91, 0x1a, 0xb4,
	0xf9, 0xb6, 0xb3, 0xb5, 0xd3, 0x73, 0xba, 0xef, 0x3b, 0x5d, 0x85, 0x65, 0x9c, 0xc6, 0x44, 0xb2,
	0x58, 0xaf, 0x76, 0x6e, 0x5c, 0x75, 0xba, 0x3b, 0xdb, 0x5b, 0x6a, 0xb0, 0x4f, 0x82, 0x84, 0xea,
	0x05, 0x23, 0x35, 0x96, 0xcb, 0xd4, 0x60, 0x74, 0xf2, 0x19, 0xbe, 0x7d, 0x74, 0xfb, 0xe8, 0xfe,
	0xb0, 0x7e, 0x19, 0x1a, 0x24, 0x91, 0x7b, 0xed, 0x4c, 0xad, 0x68, 0x1f, 0x66, 0xff, 0xed, 0xf8,
	0x7d, 0x35, 0x7f, 0x0a, 0xad, 0x25, 0xbc, 0x4f, 0x24, 0x3d, 0x1e, 0xd6, 0x5f, 0x80, 0xcf, 0xfb,
	0x24, 0x9c, 0x0f, 0x3d, 0x1e, 0xd6, 0x9f, 0x43, 0xb5, 0xdc, 0x38, 0xe5, 0xdd, 0xff, 0xf9, 0xc1,
	0x17, 0x4b, 0x26, 0xbe, 0xa2, 0xea, 0x24, 0x46, 0xdd, 0x1c, 0x61, 0xec, 0xe9, 0x15, 0x69, 0x51,
	0xdb, 0xa0, 0x89, 0x3e, 0x5b, 0x81, 0xf0, 0x96, 0x66, 0x2f, 0xea, 0xc5, 0x04, 0xb5, 0xa0, 0x17,
	0xd3, 0x40, 0xc1, 0xf1, 0xb7, 0xcb, 0x27, 0x9d, 0x4f, 0xc7, 0xbd, 0x78, 0x04, 0x66, 0x7a, 0xf1,
	0x10, 0xb4, 0xfe, 0x00, 0xf0, 0x01, 0x68, 0xfe, 0x36, 0xdb, 0x8b, 0x1f, 0x27, 0xbd, 0xf8, 0x01,
	0x18, 0xdf, 0x9f, 0x49, 0x2f, 0x52, 0x7d, 0xfd, 0x33, 0xef, 0x85, 0xf3, 0xde, 0xad, 0xce, 0xf5,
	0x5e, 0x71, 0x29, 0x9e, 0x68, 0x0d, 0x5a, 0x86, 0x59, 0xb6, 0x06, 0xf6, 0xa1, 0xdf, 0x3f, 0x52,
	0x5d, 0xf8, 0x07, 0xc0, 0x73, 0x6f, 0x51, 0xa9, 0x8b, 0xf0, 0x62, 0xf1, 0xfb, 0xcd, 0x20, 0xaa,
	0x05, 0x2f, 0x95, 0x40, 0x09, 0x8e, 0xbf, 0x06, 0x27, 0x9d, 0x73, 0x59, 0x03, 0x4a, 0x24, 0xb0,
	0x8a, 0x96, 0x3d, 0x2a, 0x17, 0xdb, 0x47, 0xe8, 0x62, 0x6e, 0xec, 0x51, 0xa9, 0xbd, 0xdb, 0xa8,
	0x9a, 0x77, 0xf4, 0x08, 0xc0, 0xda, 0x75, 0x5f, 0x68, 0xc1, 0x62, 0x8b, 0xc5, 0xef, 0xa6, 0x30,
	0xf4, 0x4a, 0xb1, 0xbd, 0x39, 0x70, 0x15, 0xc8, 0xab, 0x15, 0x19, 0x82, 0xe3, 0x8f, 0xf3, 0xe1,
	0x5c, 0x82, 0xe8, 0x54, 0x38, 0xa7, 0x42, 0xa9, 0xc1, 0xf5, 0x7c, 0x28, 0x8f, 0x0f, 0x03, 0xa3,
	0x46, 0x41, 0x18, 0xe3, 0x10, 0xd0, 0x27, 0x4b, 0x10, 0x5e, 0xa3, 0x01, 0x5d, 0xfc, 0x11, 0x98,
	0xa0, 0x16, 0x7c, 0x04, 0xa6, 0x81, 0x82, 0xe3, 0x6f, 0xaa, 0x35, 0xe0, 0x6c, 0x7e, 0x03, 0x76,
	0xb3, 0x62, 0x0f, 0x7e, 0x07, 0xf0, 0x42, 0x87, 0xf3, 0x60, 0xa0, 0xdf, 0x53, 0x4f, 0x92, 0x58,
	0xa2, 0x8d, 0x62, 0x8f, 0xa7, 0xa0, 0x2a, 0x11, 0xb3, 0x02, 0x5a, 0x70, 0x9c, 0xe4, 0x52, 0x79,
	0x16, 0x42, 0x9d, 0xca, 0xe8, 0x5c, 0x43, 0xeb, 0x44, 0x91, 0xf4, 0x57, 0x4e, 0x98, 0x42, 0xd1,
	0x8e, 0x87, 0xf5, 0x67, 0xe0, 0xd3, 0xca, 0xb1, 0x7e, 0x78, 0x3c, 0xac, 0xaf, 0xa3, 0x0b, 0xe3,
	0x63, 0x5b, 0xe3, 0xb5, 0x79, 0x03, 0xd7, 0x73, 0xe6, 0xa7, 0x36, 0xa1, 0x87, 0x00, 0x5e, 0x9c,
	0xc8, 0xd9, 0x24, 0x91, 0x4b, 0x03, 0x54, 0x4a, 0x7a, 0x8a, 0x55, 0x4e, 0xad, 0x2a, 0x70, 0xc1,
	0xf1, 0xc1, 0x63, 0xad, 0x5e, 0x42, 0x68, 0xda, 0xaa, 0xab, 0x79, 0xb3, 0x5e, 0xb3, 0x92, 0xa7,
	0x5e, 0x53, 0x50, 0x6a, 0xb6, 0x59, 0xd6, 0x6c, 0x4f, 0x12, 0x99, 0x08, 0x54, 0xf6, 0x3d, 0xc9,
	0x44, 0x94, 0x36, 0x3b, 0x82, 0x57, 0x35, 0x2b, 0x34, 0x6f, 0x81, 0xd9, 0x14, 0x94, 0x9a, 0x45,
	0x85, 0x66, 0xaf, 0x76, 0x3e, 0x78, 0xc3, 0xf3, 0xe5, 0x5e, 0xb2, 0x6b, 0xb9, 0x2c, 0xb4, 0x95,
	0xe8, 0xf1, 0xcd, 0xd1, 0x2e, 0x77, 0x99, 0xdd, 0x5d, 0xd3, 0x57, 0xc7, 0xd7, 0xfe, 0x0f, 0x00,
	0x00, 0xff, 0xff, 0x04, 0xa9, 0xa1, 0x2b, 0xd3, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// RulesClient is the client API for Rules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RulesClient interface {
	//
	//Create a project rule
	//
	//Creates a new project rule to move ingested resources into projects.
	//
	//A project rule contains conditions that determine if an ingested resource should be moved into the ruleâ€™s project.
	//
	//Each condition specifies one or more values to match for a particular attribute on an ingested resource.
	//
	//The choice of attributes depends on the rule type.
	//For NODE type, specify any of the available attributes.
	//For EVENT type, specify either CHEF_ORGANIZATION or CHEF_SERVER.
	//
	//The choice of operator depends on how many values you provide.
	//If you wish to match one among a group of values, set the operator to MEMBER_OF.
	//For a single value, use EQUALS.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	CreateRule(ctx context.Context, in *request.CreateRuleReq, opts ...grpc.CallOption) (*response.CreateRuleResp, error)
	//
	//Update a project rule
	//
	//Updates the name and conditions of an existing project rule.
	//New conditions can be added. Existing conditions can be updated or removed.
	//
	//This operation overwrites all fields excluding ID and Type,
	//including those omitted from the request, so be sure to specify all properties.
	//Properties that you do not include are reset to empty values.
	//
	//The resulting change to the project's resources does not take effect immediately.
	//Updates to project rules must be applied to ingested resources by a project update.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	UpdateRule(ctx context.Context, in *request.UpdateRuleReq, opts ...grpc.CallOption) (*response.UpdateRuleResp, error)
	//
	//Get a project rule
	//
	//Returns the details for a project rule.
	//
	//Authorization Action:
	//```
	//iam:projects:get
	//```
	GetRule(ctx context.Context, in *request.GetRuleReq, opts ...grpc.CallOption) (*response.GetRuleResp, error)
	//
	//List a project's rules
	//
	//Lists all of the project rules of a specific project.
	//
	//Authorization Action:
	//```
	//iam:projects:get
	//```
	ListRulesForProject(ctx context.Context, in *request.ListRulesForProjectReq, opts ...grpc.CallOption) (*response.ListRulesForProjectResp, error)
	//
	//Delete a project rule
	//
	//The resulting change to the project's resources does not take effect immediately.
	//Updates to project rules must be applied to ingested resources by a project update.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	DeleteRule(ctx context.Context, in *request.DeleteRuleReq, opts ...grpc.CallOption) (*response.DeleteRuleResp, error)
	//
	//Start project update
	//
	//Any changes to a project's rules are staged first. They do not take effect until
	//all projects are updated.
	//
	//Updating all projects begins an operation that applies all pending rule edits
	//and then moves ingested resources into the correct projects according to those latest changes.
	//
	//With a large amount of historical compliance data, rule application can take a considerable amount of time.
	//Itâ€™s best to batch up rule changes and apply them all at once.
	//
	//Authorization Action:
	//```
	//iam:rules:apply
	//```
	ApplyRulesStart(ctx context.Context, in *request.ApplyRulesStartReq, opts ...grpc.CallOption) (*response.ApplyRulesStartResp, error)
	//
	//Cancel project update
	//
	//Cancels an ongoing project update.
	//
	//Warning! This action leaves the system in an unknown state that only another
	//successful project update can rectify.
	//
	//This command exists really just for one scenario: you started a project update
	//but shortly thereafter discovered that you had one more change to include in the
	//batch of updates to be done.
	//
	//Authorization Action:
	//```
	//iam:rules:cancel
	//```
	ApplyRulesCancel(ctx context.Context, in *request.ApplyRulesCancelReq, opts ...grpc.CallOption) (*response.ApplyRulesCancelResp, error)
	//
	//Get the status of a project update
	//
	//Returns details about a project update operation.
	//
	//You can poll this endpoint during a project update to monitor progress.
	//Querying this endpoint when there is no update in progress will return details
	//about the completion status of the most recent update.
	//
	//Authorization Action:
	//```
	//iam:rules:status
	//```
	ApplyRulesStatus(ctx context.Context, in *request.ApplyRulesStatusReq, opts ...grpc.CallOption) (*response.ApplyRulesStatusResp, error)
}

type rulesClient struct {
	cc grpc.ClientConnInterface
}

func NewRulesClient(cc grpc.ClientConnInterface) RulesClient {
	return &rulesClient{cc}
}

func (c *rulesClient) CreateRule(ctx context.Context, in *request.CreateRuleReq, opts ...grpc.CallOption) (*response.CreateRuleResp, error) {
	out := new(response.CreateRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/CreateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) UpdateRule(ctx context.Context, in *request.UpdateRuleReq, opts ...grpc.CallOption) (*response.UpdateRuleResp, error) {
	out := new(response.UpdateRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/UpdateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) GetRule(ctx context.Context, in *request.GetRuleReq, opts ...grpc.CallOption) (*response.GetRuleResp, error) {
	out := new(response.GetRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/GetRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ListRulesForProject(ctx context.Context, in *request.ListRulesForProjectReq, opts ...grpc.CallOption) (*response.ListRulesForProjectResp, error) {
	out := new(response.ListRulesForProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/ListRulesForProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) DeleteRule(ctx context.Context, in *request.DeleteRuleReq, opts ...grpc.CallOption) (*response.DeleteRuleResp, error) {
	out := new(response.DeleteRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/DeleteRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ApplyRulesStart(ctx context.Context, in *request.ApplyRulesStartReq, opts ...grpc.CallOption) (*response.ApplyRulesStartResp, error) {
	out := new(response.ApplyRulesStartResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/ApplyRulesStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ApplyRulesCancel(ctx context.Context, in *request.ApplyRulesCancelReq, opts ...grpc.CallOption) (*response.ApplyRulesCancelResp, error) {
	out := new(response.ApplyRulesCancelResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/ApplyRulesCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesClient) ApplyRulesStatus(ctx context.Context, in *request.ApplyRulesStatusReq, opts ...grpc.CallOption) (*response.ApplyRulesStatusResp, error) {
	out := new(response.ApplyRulesStatusResp)
	err := c.cc.Invoke(ctx, "/chef.automate.api.iam.v2.Rules/ApplyRulesStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RulesServer is the server API for Rules service.
type RulesServer interface {
	//
	//Create a project rule
	//
	//Creates a new project rule to move ingested resources into projects.
	//
	//A project rule contains conditions that determine if an ingested resource should be moved into the ruleâ€™s project.
	//
	//Each condition specifies one or more values to match for a particular attribute on an ingested resource.
	//
	//The choice of attributes depends on the rule type.
	//For NODE type, specify any of the available attributes.
	//For EVENT type, specify either CHEF_ORGANIZATION or CHEF_SERVER.
	//
	//The choice of operator depends on how many values you provide.
	//If you wish to match one among a group of values, set the operator to MEMBER_OF.
	//For a single value, use EQUALS.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	CreateRule(context.Context, *request.CreateRuleReq) (*response.CreateRuleResp, error)
	//
	//Update a project rule
	//
	//Updates the name and conditions of an existing project rule.
	//New conditions can be added. Existing conditions can be updated or removed.
	//
	//This operation overwrites all fields excluding ID and Type,
	//including those omitted from the request, so be sure to specify all properties.
	//Properties that you do not include are reset to empty values.
	//
	//The resulting change to the project's resources does not take effect immediately.
	//Updates to project rules must be applied to ingested resources by a project update.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	UpdateRule(context.Context, *request.UpdateRuleReq) (*response.UpdateRuleResp, error)
	//
	//Get a project rule
	//
	//Returns the details for a project rule.
	//
	//Authorization Action:
	//```
	//iam:projects:get
	//```
	GetRule(context.Context, *request.GetRuleReq) (*response.GetRuleResp, error)
	//
	//List a project's rules
	//
	//Lists all of the project rules of a specific project.
	//
	//Authorization Action:
	//```
	//iam:projects:get
	//```
	ListRulesForProject(context.Context, *request.ListRulesForProjectReq) (*response.ListRulesForProjectResp, error)
	//
	//Delete a project rule
	//
	//The resulting change to the project's resources does not take effect immediately.
	//Updates to project rules must be applied to ingested resources by a project update.
	//
	//Authorization Action:
	//```
	//iam:projects:update
	//```
	DeleteRule(context.Context, *request.DeleteRuleReq) (*response.DeleteRuleResp, error)
	//
	//Start project update
	//
	//Any changes to a project's rules are staged first. They do not take effect until
	//all projects are updated.
	//
	//Updating all projects begins an operation that applies all pending rule edits
	//and then moves ingested resources into the correct projects according to those latest changes.
	//
	//With a large amount of historical compliance data, rule application can take a considerable amount of time.
	//Itâ€™s best to batch up rule changes and apply them all at once.
	//
	//Authorization Action:
	//```
	//iam:rules:apply
	//```
	ApplyRulesStart(context.Context, *request.ApplyRulesStartReq) (*response.ApplyRulesStartResp, error)
	//
	//Cancel project update
	//
	//Cancels an ongoing project update.
	//
	//Warning! This action leaves the system in an unknown state that only another
	//successful project update can rectify.
	//
	//This command exists really just for one scenario: you started a project update
	//but shortly thereafter discovered that you had one more change to include in the
	//batch of updates to be done.
	//
	//Authorization Action:
	//```
	//iam:rules:cancel
	//```
	ApplyRulesCancel(context.Context, *request.ApplyRulesCancelReq) (*response.ApplyRulesCancelResp, error)
	//
	//Get the status of a project update
	//
	//Returns details about a project update operation.
	//
	//You can poll this endpoint during a project update to monitor progress.
	//Querying this endpoint when there is no update in progress will return details
	//about the completion status of the most recent update.
	//
	//Authorization Action:
	//```
	//iam:rules:status
	//```
	ApplyRulesStatus(context.Context, *request.ApplyRulesStatusReq) (*response.ApplyRulesStatusResp, error)
}

// UnimplementedRulesServer can be embedded to have forward compatible implementations.
type UnimplementedRulesServer struct {
}

func (*UnimplementedRulesServer) CreateRule(ctx context.Context, req *request.CreateRuleReq) (*response.CreateRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRule not implemented")
}
func (*UnimplementedRulesServer) UpdateRule(ctx context.Context, req *request.UpdateRuleReq) (*response.UpdateRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRule not implemented")
}
func (*UnimplementedRulesServer) GetRule(ctx context.Context, req *request.GetRuleReq) (*response.GetRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (*UnimplementedRulesServer) ListRulesForProject(ctx context.Context, req *request.ListRulesForProjectReq) (*response.ListRulesForProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRulesForProject not implemented")
}
func (*UnimplementedRulesServer) DeleteRule(ctx context.Context, req *request.DeleteRuleReq) (*response.DeleteRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRule not implemented")
}
func (*UnimplementedRulesServer) ApplyRulesStart(ctx context.Context, req *request.ApplyRulesStartReq) (*response.ApplyRulesStartResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesStart not implemented")
}
func (*UnimplementedRulesServer) ApplyRulesCancel(ctx context.Context, req *request.ApplyRulesCancelReq) (*response.ApplyRulesCancelResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesCancel not implemented")
}
func (*UnimplementedRulesServer) ApplyRulesStatus(ctx context.Context, req *request.ApplyRulesStatusReq) (*response.ApplyRulesStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesStatus not implemented")
}

func RegisterRulesServer(s *grpc.Server, srv RulesServer) {
	s.RegisterService(&_Rules_serviceDesc, srv)
}

func _Rules_CreateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.CreateRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).CreateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/CreateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).CreateRule(ctx, req.(*request.CreateRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.UpdateRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/UpdateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).UpdateRule(ctx, req.(*request.UpdateRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.GetRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/GetRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).GetRule(ctx, req.(*request.GetRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ListRulesForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ListRulesForProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ListRulesForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/ListRulesForProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ListRulesForProject(ctx, req.(*request.ListRulesForProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DeleteRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/DeleteRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).DeleteRule(ctx, req.(*request.DeleteRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ApplyRulesStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ApplyRulesStartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ApplyRulesStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/ApplyRulesStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ApplyRulesStart(ctx, req.(*request.ApplyRulesStartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ApplyRulesCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ApplyRulesCancelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ApplyRulesCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/ApplyRulesCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ApplyRulesCancel(ctx, req.(*request.ApplyRulesCancelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rules_ApplyRulesStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ApplyRulesStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServer).ApplyRulesStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.iam.v2.Rules/ApplyRulesStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServer).ApplyRulesStatus(ctx, req.(*request.ApplyRulesStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Rules_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chef.automate.api.iam.v2.Rules",
	HandlerType: (*RulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRule",
			Handler:    _Rules_CreateRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _Rules_UpdateRule_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _Rules_GetRule_Handler,
		},
		{
			MethodName: "ListRulesForProject",
			Handler:    _Rules_ListRulesForProject_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _Rules_DeleteRule_Handler,
		},
		{
			MethodName: "ApplyRulesStart",
			Handler:    _Rules_ApplyRulesStart_Handler,
		},
		{
			MethodName: "ApplyRulesCancel",
			Handler:    _Rules_ApplyRulesCancel_Handler,
		},
		{
			MethodName: "ApplyRulesStatus",
			Handler:    _Rules_ApplyRulesStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "components/automate-gateway/api/iam/v2/rules.proto",
}
